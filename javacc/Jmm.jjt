options
{
    LOOKAHEAD=1;
    //CHOICE_AMBIGUITY_CHECK=6;
    //DEBUG_LOOKAHEAD=true;
    //DEBUG_PARSER=true;
    //FORCE_LA_CHECK=true;
}

PARSER_BEGIN(Jmm)


import java.util.Arrays;
public class Jmm
{
    public static void main(String[] args) throws ParseException {
      	System.out.println("Write a jmm arithmetic:");
		Jmm jmm = new Jmm(System.in);
		SimpleNode root = jmm.Program(); // returns reference to root node

		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
}

PARSER_END(Jmm)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}
// comments (source: https://javacc.github.io/javacc/documentation/bnf.html)
<DEFAULT> MORE : { "//" : IN_SINGLE_LINE_COMMENT
                 | <"/**" ~["/"]> : IN_FORMAL_COMMENT
                 | "/*" : IN_MULTI_LINE_COMMENT
                 | "/*@bgen(jjtree" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN : {
  <FORMAL_COMMENT: "*/"> : DEFAULT
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN : {
  <MULTI_LINE_COMMENT: "*/"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT> MORE : {
  <~[]>
}

// reserved words and literals
TOKEN:
{
    <NEW: "new">
    |   <THIS: "this">
    |   <TRUE: "true"> | <FALSE: "false">
    |   <IF: "if"> | <ELSE: "else">
    |   <WHILE: "while">
    |   <BOOL: "boolean"> | <INT: "int">
    |   <VOID: "void">
    |   <PUBLIC: "public"> | <STATIC: "static">
    |   <MAIN: "main"> | <STRING: "String">
    |   <CLASS: "class"> | <EXTENDS: "extends">
    |   <IMPORT: "import">
    |   <RET: "return">
    |   <LEN: ".length"> // storing as .length because length can be an identifier
    // |   <LF>: "\n"
}

// integer literals and identifiers
// IMP: unicode literal matching is not ok
TOKEN : {
    <IDENTIFIER: <LETTER> (<LETTERNUM>)*>
    |   <#LETTER: ["A"-"Z", "a"-"z", "_", "$"]>
    |   <#LETTERNUM: ["A"-"Z", "a"-"z", "0"-"9", "_", "$"]>
    |   <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?
        |   <HEX_LITERAL> (["l","L"])?
        |   <OCTAL_LITERAL> (["l","L"])?
        |   <BINARY_LITERAL> (["l","L"])?>
    | <#DECIMAL_LITERAL: ["1"-"9"] (("_")* ["0"-"9"])*>
    | <#HEX_LITERAL: "0" ["x","X"] ["0"-"9","a"-"f","A"-"F"] (("_")* ["0"-"9","a"-"f","A"-"F"])*>
    | <#OCTAL_LITERAL: "0" (("_")* ["0"-"7"])*>
    | <#BINARY_LITERAL: "0" ["b","B"] ["0","1"] (("_")* ["0","1"])*>
}

// separators
TOKEN : {
    <SPAR: "("> | <EPAR: ")">
    |   <SBRAK: "["> | <EBRAK: "]" >
    |   <SCURL: "{"> | <ECURL: "}">
    |   <DOT: "."> | <COMMA: ",">
    |   <SEMICOLON: ";">
}

// operators
TOKEN : {
    <ASSIGN: "=">
    |   <NOT: "!"> | <AND: "&&"> | <LESSTHAN: "<">
    |   <ADD: "+"> | <SUB: "-"> | <MULT: "*"> | <DIV: "/">
}

SimpleNode Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] // can only extend once
    <SCURL>
        ClassBody()
    <ECURL>
}

void ClassBody() : {}
{
    (VarDeclaration())*
    (MethodDeclaration())*
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER>
    <SPAR>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <EPAR>
    <SCURL>
        MethodBody()
        <RET> Expression() <SEMICOLON>
    <ECURL>
    |
    <STATIC> <VOID> <MAIN>
    <SPAR>
        <STRING> <SBRAK> <EBRAK> <IDENTIFIER>
    <EPAR>
    <SCURL>
        MethodBody()
    <ECURL>)
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())* // TODO maybe LOOKAHEAD(2) ?
}

void Type() : {}
{
    <INT> [<SBRAK> <EBRAK>]
    |   <BOOL>
    |   <IDENTIFIER>
}

void Statement() : {}
{
    <SCURL> (Statement())* <ECURL>
    |   <IF> <SPAR> Expression() <EPAR> Statement() <ELSE> Statement()
    |   WhileLoop()
    |   [LOOKAHEAD(5) <IDENTIFIER> [<SBRAK> Expression() <EBRAK>] <ASSIGN>] Expression() <SEMICOLON>
    // IMP LOOKAHEAD(5) to disambiuate a[0] = 1; and a[0];
}

void WhileLoop() : {}
{
    <WHILE>
    try { <SPAR> } // report missing start parentheses "("
    catch (ParseException e) { error_ignore(e); }

    try { Expression()
        try { <EPAR> }
        catch (ParseException e) { error_ignore(e); }
    } catch (ParseException e) { error_skipto(e, new Integer[]{ EPAR, SCURL, SEMICOLON }, new Integer[]{ EPAR, SEMICOLON }); }

   try { Statement() }
   catch (ParseException e) { error_skipto(e, new Integer[]{ ECURL, SEMICOLON }, new Integer[]{ ECURL, SEMICOLON }); }
}

void Expression() : {}
{
    (<INTEGER_LITERAL>
    |   <TRUE>
    |   <FALSE>
    |   <THIS>
    |   <NEW> (<INT> <SBRAK> Expression() <EBRAK>
                |   <IDENTIFIER> <SPAR> <EPAR>)
    |   <NOT> Expression()
    |   <SPAR> Expression() <EPAR>
    |   <IDENTIFIER>) ExpressionTail()
}

void ExpressionTail() : {}
{
    [LOOKAHEAD(2) (Op() Expression()
    |   <SBRAK> Expression() <EBRAK>
    |   <LEN>
    |   <DOT> <IDENTIFIER> <SPAR> [Expression() (<COMMA> Expression())*] <EPAR>
    ) ExpressionTail()]
}

void Op() : {}
{
    <AND> | <LESSTHAN> | <ADD> | <SUB> | <MULT> | <DIV>
}

JAVACODE
void error_skipto(ParseException e, Integer[] skipto, Integer[] toconsume) {
  System.err.println(e.toString());  // print the error message
  Token t = getToken(1);
  // consume tokens until the next token is of "kind"
  while (!Arrays.asList(skipto).contains(t.kind) && t.kind != 0) {
    getNextToken();
    t = getToken(1);
  }

  if (Arrays.asList(toconsume).contains(t.kind)) getNextToken();
}

JAVACODE
void error_ignore(ParseException e) {
  System.err.println(e.toString());  // print the error message
}

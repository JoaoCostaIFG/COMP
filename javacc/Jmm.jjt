options
{
    LOOKAHEAD=1;
    //NODE_DEFAULT_VOID = true; // don't generate nodes by default

    //CHOICE_AMBIGUITY_CHECK=5;
    //OTHER_AMBIGUITY_CHECK=3;
    DEBUG_PARSER=true;
    DEBUG_LOOKAHEAD=true;
    //DEBUG_TOKEN_MANAGER=true;

    //FORCE_LA_CHECK=true;
}

PARSER_BEGIN(Jmm)

import java.util.Arrays;
public class Jmm
{
    public static void main(String[] args) throws ParseException {
      	System.out.println("Write a jmm arithmetic:");
		Jmm jmm = new Jmm(System.in);
		SimpleNode root = jmm.Program(); // returns reference to root node

		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
}

PARSER_END(Jmm)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}
// comments (source: https://javacc.github.io/javacc/documentation/bnf.html)
<DEFAULT> MORE : { "//" : IN_SINGLE_LINE_COMMENT
                 | <"/**" ~["/"]> : IN_FORMAL_COMMENT
                 | "/*" : IN_MULTI_LINE_COMMENT
                 | "/*@bgen(jjtree" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN : {
  <FORMAL_COMMENT: "*/"> : DEFAULT
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN : {
  <MULTI_LINE_COMMENT: "*/"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT> MORE : {
  <~[]>
}

// reserved words and literals
TOKEN:
{
    <NEW: "new">
    |   <THIS: "this">
    |   <TRUE: "true"> | <FALSE: "false">
    |   <IF: "if"> | <ELSE: "else">
    |   <WHILE: "while">
    |   <BOOL: "boolean"> | <INT: "int">
    |   <VOID: "void">
    |   <PUBLIC: "public"> | <STATIC: "static">
    |   <MAIN: "main"> | <STRING: "String">
    |   <CLASS: "class"> | <EXTENDS: "extends">
    |   <IMPORT: "import">
    |   <RET: "return">
    |   <LEN: "length"> // IMP storing as .length would enable variables to be called "length" (see DotTer())
    // |   <LF>: "\n" // we skip "\n" instead of matching it
}

// integer literals and identifiers
// IMP: unicode literal matching is not ok
TOKEN : {
    <IDENTIFIER: <LETTER> (<LETTERNUM>)*>
    |   <#LETTER: ["A"-"Z", "a"-"z", "_", "$"]>
    |   <#LETTERNUM: ["A"-"Z", "a"-"z", "0"-"9", "_", "$"]>
    |   <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?
        |   <HEX_LITERAL> (["l","L"])?
        |   <OCTAL_LITERAL> (["l","L"])?
        |   <BINARY_LITERAL> (["l","L"])?>
    | <#DECIMAL_LITERAL: ["1"-"9"] (("_")* ["0"-"9"])*>
    | <#HEX_LITERAL: "0" ["x","X"] ["0"-"9","a"-"f","A"-"F"] (("_")* ["0"-"9","a"-"f","A"-"F"])*>
    | <#OCTAL_LITERAL: "0" (("_")* ["0"-"7"])*>
    | <#BINARY_LITERAL: "0" ["b","B"] ["0","1"] (("_")* ["0","1"])*>
}

// separators
TOKEN : {
    <SPAR: "("> | <EPAR: ")">
    |   <SBRAK: "["> | <EBRAK: "]" >
    |   <SCURL: "{"> | <ECURL: "}">
    |   <DOT: "."> | <COMMA: ",">
    |   <SEMICOLON: ";">
}

// operators
TOKEN : {
    <ASSIGN: "=">
    |   <NOT: "!"> | <AND: "&&"> | <LESSTHAN: "<">
    |   <ADD: "+"> | <SUB: "-"> | <MUL: "*"> | <DIV: "/">
}

SimpleNode Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] // can only extend once
    <SCURL>
        ClassBody()
    <ECURL>
}

void ClassBody() : {}
{
    (VarDeclaration())*
    (MethodDeclaration())*
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER>
    <SPAR>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <EPAR>
    <SCURL>
        MethodBody()
        <RET> Expression() <SEMICOLON>
    <ECURL>
    |
    <STATIC> <VOID> <MAIN>
    <SPAR>
        <STRING> <SBRAK> <EBRAK> <IDENTIFIER>
    <EPAR>
    <SCURL>
        MethodBody()
    <ECURL>)
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())* // TODO maybe LOOKAHEAD(2) ?
}

void Type() : {}
{
    <INT> [<SBRAK> <EBRAK>]
    |   <BOOL>
    |   <IDENTIFIER>
}

void WhileLoop() : {}
{
    <WHILE>
    try { <SPAR> } // report missing start parentheses "("
    catch (ParseException e) {
        error_ignore(e, "expected '(' at the start of the while loop expression");
    }

    try { Expression()
        try { <EPAR> }
        catch (ParseException e) {
            error_ignore(e, "expected ')' at the end of the while loop expression");
        }
    } catch (ParseException e) {
        error_skipto(e, "couldn't parse expression starting at '" +
            getToken(0).image + "' inside while loop",
            new Integer[]{ EPAR, SCURL, SEMICOLON },
            new Integer[]{ EPAR, SEMICOLON });
    }

    try { Statement() }
    catch (ParseException e) {
        error_skipto(e, "couldn't parse statement starting at '" +
        getToken(0).image + "' in while loop body",
        new Integer[]{ ECURL, SEMICOLON },
        new Integer[]{ ECURL, SEMICOLON });
    }
}

void Statement() : {}
{
    <SCURL> (Statement())* <ECURL> // statment block
    |   <IF> <SPAR> Expression() <EPAR> Statement() <ELSE> Statement() // if then else
    |   WhileLoop() // while loop
    |   [LOOKAHEAD(5) <IDENTIFIER> [<SBRAK> Expression() <EBRAK>] <ASSIGN>] Expression() <SEMICOLON>
    // TODO assign go from statement to expression
    // IMP LOOKAHEAD(5) to disambiuate a[0] = 1; and a[0];
}

void Expression() : {Token op;}
{
    LessThanTerm()
    (op=<AND> LessThanTerm())*
}

void LessThanTerm() #void : {Token op;}
{
    AdditiveTerm()
    (op=<LESSTHAN> AdditiveTerm())*
}

void AdditiveTerm() #void : {Token op;}
{
    MultiplicativeTerm()
    (op=<ADD> MultiplicativeTerm()
    |   op=<SUB> MultiplicativeTerm())*
}

void MultiplicativeTerm() : {Token op;}
{
    NotTerm()
    (op=<MUL> {jjtThis.put("op", op.image);} NotTerm()
    |   op=<DIV> {jjtThis.put("op", op.image);} NotTerm())*
}

void NotTerm() #void : {}
{
    <NOT> NotTerm()
    |   DotTerm()
}

void DotTerm() #void : {}
{
    // If we didn't want "length" to be a reserved word, we could store <LEN> as ".length"
    // and match like so:
    // ArrayAccessTerm()
    // (<LEN>
    // |    <DOT> DotExpansion())*

    ArrayAccessTerm()
    (<DOT> (<LEN> | DotExpansion()))*
}

void DotExpansion() #void : {}
{
    <IDENTIFIER>
    <SPAR>
        [Expression() (<COMMA> Expression())*]
    <EPAR>
}

void ArrayAccessTerm() #void : {}
{
    ExpressionTerminal() [<SBRAK> Expression() <EBRAK>]
}

void ExpressionTerminal() #void : { Token t; }
{
    <TRUE> #BoolLiteral
    |   <FALSE> #BoolLiteral
    |   <THIS> #ThisLiteral
    |   <SPAR> Expression() <EPAR>
    |   <NEW> NewTerm() #NewLiteral
    |   t = <INTEGER_LITERAL> #IntegerLiteral
    |   t = <IDENTIFIER> #Identifier
}

void NewTerm() : {}  // 04:14
{
    <INT> <SBRAK> Expression() <EBRAK> // array allocation
    |   <IDENTIFIER> <SPAR> <EPAR> // class constructor
}

JAVACODE
void error_skipto(ParseException e, String errMsg, Integer[] skipto, Integer[] toconsume) {
    e.setErrMsg(errMsg);
    System.err.println(e.getErrMsg());  // print the error message

    Token t = getToken(1);
    // consume tokens until the next token is of "kind"
    while (!Arrays.asList(skipto).contains(t.kind) && t.kind != 0) {
        getNextToken();
        t = getToken(1);
    }

    if (Arrays.asList(toconsume).contains(t.kind)) getNextToken();
}

JAVACODE
void error_ignore(ParseException e, String errMsg) {
    e.setErrMsg(errMsg);
    System.err.println(e.getErrMsg());  // print the error message
}

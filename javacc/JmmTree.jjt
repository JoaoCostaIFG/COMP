options
{
    LOOKAHEAD=2;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(JmmTree)


public class JmmTree
{
    public static void main(String[] args) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		JmmTree jmmTree = new JmmTree(System.in);
		SimpleNode root = jmmTree.Program(); // returns reference to root node

		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
}

PARSER_END(JmmTree)

SKIP :
{
	" " | "\r" | "\t" | "\n"
	|   < "//" (~["\r", "\n"])* >
	|   "/*" : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
    "*/" : DEFAULT
    | < ~[] >
}

// reserved keywords
TOKEN:
{
    <NEW: "new">
    |   <THIS: "this">
    |   <TRUE: "true"> | <FALSE: "false">
    |   <IF: "if"> | <ELSE: "else">
    |   <WHILE: "while">
    |   <BOOL: "boolean"> | <INT: "int">
    |   <VOID: "void">
    |   <PUBLIC: "public"> | <STATIC: "static">
    |   <MAIN: "main"> | <STRING: "String">
    |   <CLASS: "class"> | <EXTENDS: "extends">
    |   <IMPORT: "import">
    |   <RET: "return">
    |   <LEN: ".length"> // storing as .length because length can be an identifier
    // |   <LF>: "\n"
}

// integer and identifiers
TOKEN : {
    <IDENTIFIER: ["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a"-"z", "_", "$"])*>
    |	<INTEGER: (["0"-"9"])+>
}

// other
TOKEN : {
    <SPAR: "("> | <EPAR: ")">
    |   <SBRAK: "["> | <EBRAK: "]" >
    |   <SCURL: "{"> | <ECURL: "}">
    |   <DOT: "."> | <COMMA: ",">
    |   <NOT: "!"> | <AND: "&&"> | <LESSTHAN: "<">
    |   <ADD: "+"> | <SUB: "-"> | <MULT: "*"> | <DIV: "/">
    |   <ATTRIB: "=">
    |   <SEMICOLON: ";">
}

SimpleNode Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;} // Java code inside brackets
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>]
    <SCURL>
        (VarDeclaration())*
        (MethodDeclaration())*
    <ECURL>
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER>
    <SPAR>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <EPAR>
    <SCURL>
        MethodBody()
        <RET> Expression() <SEMICOLON>
    <ECURL>
    |
    <STATIC> <VOID> <MAIN>
    <SPAR>
        <STRING> <SBRAK> <EBRAK> <IDENTIFIER>
    <EPAR>
    <SCURL>
        MethodBody()
    <ECURL>)
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (LOOKAHEAD(2) Statement())*
}

void Type() : {}
{
    <INT> [<SBRAK> <EBRAK>]
    |   <BOOL>
    |   <IDENTIFIER>
}

void Statement() : {}
{
    <SCURL> (Statement())* <ECURL>
    |   <IF> <SPAR> Expression() <EPAR> Statement() <ELSE> Statement()
    |   <WHILE> <SPAR> Expression() <EPAR> Statement()
    |   Expression() <SEMICOLON>
    |   <IDENTIFIER> [<SBRAK> Expression() <EBRAK>] <ATTRIB> Expression() <SEMICOLON>
}

void Expression() : {}
{
    (<INTEGER>
    |   <TRUE>
    |   <FALSE>
    |   <THIS>
    |   <NEW> (<INT> <SBRAK> Expression() <EBRAK>
                |   <IDENTIFIER> <SPAR> <EPAR>)
    |   <NOT> Expression()
    |   <SPAR> Expression() <EPAR>
    |   <IDENTIFIER>) ExpressionTail()
}

void ExpressionTail() : {}
{
    [(Op() Expression()
    |   <SBRAK> Expression() <EBRAK>
    |   <LEN>
    |   <DOT> <IDENTIFIER> <SPAR> [Expression() (<COMMA> Expression())*] <EPAR>
    ) ExpressionTail()]
}

void Op() : {}
{
    <AND> | <LESSTHAN> | <ADD> | <SUB> | <MULT> | <DIV>
}
# Compilers

## GROUP: 1C

- NAME1: Ana Inês Oliveira de Barros, NR1: 201806593, GRADE1: 20, CONTRIBUTION1:
  25%
- NAME2: João de Jesus Costa, NR2: 201806560, GRADE2: 20, CONTRIBUTION2: 25%
- NAME3: João Lucas Silva Martins, NR3: 20180643, GRADE3: 20, CONTRIBUTION3: 25%
- NAME4: Ricardo Jorge Cruz Fontão, NR4: 201806317, GRADE4: 20, CONTRIBUTION4:
  25%

GLOBAL Grade of the project: 20

### SUMMARY

Our tool compiles Java-- (jmm), a java language subset, code files. It optimizes
the code and compiles it to jasmin, saving it in a file. Its main features
are: - Semantic analysis; - Syntactic analysis; - Code optimization; - Jasmin
code generation.

### DEALING WITH SYNTACTIC ERRORS

We store the line and column of every node using a hook. We do this so we can
show the line and column corresponding to the errors that are reported. When
encountering an error outside a while loop, the error is reported and the
analysis stops. Errors inside while loops are accumulated, because the analysis
doesn't stop, and reported at the end of the parsing.

### SEMANTIC ANALYSIS

Semantic rules implemented:

- Type verifications in expressions:

  - Operands must have the same type;
  - It is not possible to use arrays directly in arithmetic operations (e.g.
    array1 + array2);
  - Array access only applies to arrays;
  - The array index on an array access must be an integer;
  - The type of an assignee and the type of an assigned must be equal;
  - Boolean operations must only use boolean operators (&&, <, !);
  - Conditional expressions must result in a boolean value.

- Method Verifications:

  - Both the method and its target must exist;
  - Number of arguments in the invocation call must be equal to the number of
    parameters in the method's declaration (method overloading is taken into
    account);
  - The arguments type must be equal to the parameters type.

- Extras:
  - Arrays must be one dimensional
  - Class parameters cannot be used in a static context (e.g.: inside main
    function);
  - Variables must be initialized before being used;
  - Arrays need to be initialized before we can use their indices;
  - There can only be one main function;
  - Variables must be declared before being used/assigned a value;
  - .length can only be used in arrays;
  - Methods can only be called on class instances and statically from imports;
  - "Not a statement errors": a line containing only `1 + 1;` isn't a valid
    statement.

### CODE GENERATION

Our code generation takes as input the OLLIR generated by the
`OptimizationStage` class and outputs the jasmin code. The only problem (we know
of) regarding our code generation is that, when allocating registers, our tool
does not perform spilling.

### TASK DISTRIBUTION

- Ana Barros:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Tests
  - README.md

- João Costa:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Optimizations
  - Jasmin
  - Register allocation

- João Lucas:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Tests

- Ricardo Fontão:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Code examples for delivery
  - Tests
  - build.gradle

### PROS

- Many extra semantic verifications (described above in the extras section of
  the SEMANTIC ANALYSIS chapter);
- Register allocation (-r);
- Improved while template (-o);
- Constant propagation optimization (-o);
- Constant folding optimization (extra);
- Optimization (extra) by removing dead code on assigments, e.g.: if the
  variable `a` in `a = 1;` is never used (besides being assigned a value), the
  instruction is removed from the final code. This is useful when combined with
  the constant propagation and folding optimizations.
- When using constant propagation and constant folding, we apply the propagation
  to "if" and "while"'s bodies when possible, e.g.:

  ```java
  int i = 0;
  if (j < 0) {
    i = i * 2;
  } else {
    i = 2;
  }
  i = i + 1;

  // becomes

  int i = 0;
  if (j < 0) {
    i = 0; // constant propagation and folding
  } else {
    i = 2;
  }
  // notice that the constant wasn't propagated here
  i = i + 1;
  ```

- Use of optimized operations such as: `iconst_<n>`, `ifgt`, `iinc`, etc...
- Increments/decrements by 0, such as: `i = i + 0` are skipped.
- Increments/decrements also make of the `iinc` instruction when written like
  so: `i = 1 + i;`. Note: it isn't applied for statements such as: `i = 1 - i;`,
  but it is applied for statements such as: `i = 1 + i;`.

### CONS

- Register allocation is only performed for integer and boolean variables.


options
{
    LOOKAHEAD=1;
    //CHOICE_AMBIGUITY_CHECK=6;
    //DEBUG_LOOKAHEAD=true;
    //DEBUG_PARSER=true;
    //FORCE_LA_CHECK=true;
}

PARSER_BEGIN(JmmTree)


public class JmmTree
{
    public static void main(String[] args) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		JmmTree jmmTree = new JmmTree(System.in);
		SimpleNode root = jmmTree.Program(); // returns reference to root node

		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
}

PARSER_END(JmmTree)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}
// comments (source: https://javacc.github.io/javacc/documentation/bnf.html)
<DEFAULT> MORE : { "//" : IN_SINGLE_LINE_COMMENT
                 | <"/**" ~["/"]> : IN_FORMAL_COMMENT
                 | "/*" : IN_MULTI_LINE_COMMENT
                 | "/*@bgen(jjtree" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN : {
  <FORMAL_COMMENT: "*/"> : DEFAULT
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN : {
  <MULTI_LINE_COMMENT: "*/"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT> MORE : {
  <~[]>
}

// reserved words and literals
TOKEN:
{
    <NEW: "new">
    |   <THIS: "this">
    |   <TRUE: "true"> | <FALSE: "false">
    |   <IF: "if"> | <ELSE: "else">
    |   <WHILE: "while">
    |   <BOOL: "boolean"> | <INT: "int">
    |   <VOID: "void">
    |   <PUBLIC: "public"> | <STATIC: "static">
    |   <MAIN: "main"> | <STRING: "String">
    |   <CLASS: "class"> | <EXTENDS: "extends">
    |   <IMPORT: "import">
    |   <RET: "return">
    |   <LEN: ".length"> // storing as .length because length can be an identifier
    // |   <LF>: "\n"
}

// integer literals and identifiers
// TODO: match octal, hex, and bin?
TOKEN : {
    <IDENTIFIER: <LETTER> (<LETTERNUM>)*>
    |   <#LETTER: ["A"-"Z", "a"-"z", "_", "$"]>
    |   <#LETTERNUM: ["A"-"Z", "a"-"z", "0"-"9", "_", "$"]>
    |   <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?>
    |   <#DECIMAL_LITERAL: ["0"-"9"] (("_")* ["0"-"9"])*>
}

// separators
TOKEN : {
    <SPAR: "("> | <EPAR: ")">
    |   <SBRAK: "["> | <EBRAK: "]" >
    |   <SCURL: "{"> | <ECURL: "}">
    |   <DOT: "."> | <COMMA: ",">
    |   <SEMICOLON: ";">
}

// operators
TOKEN : {
    <ATTRIB: "=">
    |   <NOT: "!"> | <AND: "&&"> | <LESSTHAN: "<">
    |   <ADD: "+"> | <SUB: "-"> | <MULT: "*"> | <DIV: "/">
}

SimpleNode Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] // can only extend once
    <SCURL>
        ClassBody()
    <ECURL>
}

void ClassBody() : {}
{
    (VarDeclaration())*
    (MethodDeclaration())*
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER>
    <SPAR>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <EPAR>
    <SCURL>
        MethodBody()
        <RET> Expression() <SEMICOLON>
    <ECURL>
    |
    <STATIC> <VOID> <MAIN>
    <SPAR>
        <STRING> <SBRAK> <EBRAK> <IDENTIFIER>
    <EPAR>
    <SCURL>
        MethodBody()
    <ECURL>)
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())* // TODO maybe LOOKAHEAD(2) ?
}

void Type() : {}
{
    <INT> [<SBRAK> <EBRAK>]
    |   <BOOL>
    |   <IDENTIFIER>
}

void Statement() : {}
{
    <SCURL> (Statement())* <ECURL>
    |   <IF> <SPAR> Expression() <EPAR> Statement() <ELSE> Statement()
    |   <WHILE> <SPAR> Expression() <EPAR> Statement()
    |   [LOOKAHEAD(5) <IDENTIFIER> [<SBRAK> Expression() <EBRAK>] <ATTRIB>] Expression() <SEMICOLON>
    // IMP LOOKAHEAD(5) to disambiuate a[0] = 1; and a[0];
}

void Expression() : {}
{
    (<INTEGER_LITERAL>
    |   <TRUE>
    |   <FALSE>
    |   <THIS>
    |   <NEW> (<INT> <SBRAK> Expression() <EBRAK>
                |   <IDENTIFIER> <SPAR> <EPAR>)
    |   <NOT> Expression()
    |   <SPAR> Expression() <EPAR>
    |   <IDENTIFIER>) ExpressionTail()
}

void ExpressionTail() : {}
{
    [(Op() Expression()
    |   <SBRAK> Expression() <EBRAK>
    |   <LEN>
    |   <DOT> <IDENTIFIER> <SPAR> [Expression() (<COMMA> Expression())*] <EPAR>
    ) ExpressionTail()]
}

void Op() : {}
{
    <AND> | <LESSTHAN> | <ADD> | <SUB> | <MULT> | <DIV>
}
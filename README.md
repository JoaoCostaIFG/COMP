# Compilers

## GROUP: 1C

- NAME1: Ana Inês Oliveira de Barros, NR1: 201806593, GRADE1: 20, CONTRIBUTION1:
  25%
- NAME2: João de Jesus Costa, NR2: 201806560, GRADE2: 20, CONTRIBUTION2: 25%
- NAME3: João Lucas Silva Martins, NR3: 20180643, GRADE3: 20, CONTRIBUTION3: 25%
- NAME4: Ricardo Jorge Cruz Fontão, NR4: 201806317, GRADE4: 20, CONTRIBUTION4:
  25%

GLOBAL Grade of the project: 20

### SUMMARY

Our tool compiles Java-- (jmm), a java language subset, code files. It optimizes
the code and compiles it to jasmin, saving it in a file. Its main features
are: - Semantic analysis; - Syntactic analysis; - Code optimization; - Jasmin
code generation.

### DEALING WITH SYNTACTIC ERRORS

We store the line and column of every node using a hook. We do this, so we can
show the line and column corresponding to the errors that are reported. When
encountering an error outside a while loop, the error is reported, and the
analysis stops. Errors inside while loop conditions are accumulated, because
the analysis doesn't stop (error recovery), and reported at the end of the
parsing.

### SEMANTIC ANALYSIS

Semantic rules implemented:

- Type verifications in expressions:

  - Operands must have the same type;
  - It is not possible to use arrays directly in arithmetic operations (e.g.
    array1 + array2);
  - Array access only applies to arrays;
  - The array index on an array access must be an integer;
  - The type of an assignee and the type of an assigned must be equal;
  - Boolean operations must only use boolean operators (&&, <, !);
  - Conditional expressions must result in a boolean value.

- Method Verifications:

  - Both the method and its target must exist;
  - Number of arguments in the invocation call must be equal to the number of
    parameters in the method's declaration (method overloading is taken into
    account);
  - The arguments type must be equal to the parameters type.

- Extras:
  - Arrays must be one dimensional
  - Class parameters cannot be used in a static context (e.g.: inside main
    function);
  - Variables must be initialized before being used;
  - Arrays need to be initialized before we can use their indices;
  - There can only be one main function;
  - Variables must be declared before being used/assigned a value;
  - .length can only be used in arrays;
  - Methods can only be called on class instances and statically from imports;
  - "Not a statement errors": a line containing only `1 + 1;` isn't a valid
    statement.

### CODE GENERATION

Our code generation takes as input the OLLIR generated by the
`OptimizationStage` class and outputs the jasmin code. The only problem (we know
of) regarding our code generation is that, when allocating registers, our tool
does not perform spilling.

- Register allocation (-r);
- Improved while template (-o);
- Constant propagation optimization (-o);
- Constant folding optimization (extra);
- Optimization (extra) by removing dead code on assigments, e.g.: if the
  variable `a` in `a = 1;` is never used (besides being assigned a value), the
  instruction is removed from the final code. This is useful when combined with
  the constant propagation and folding optimizations;
- Use of optimized operations such as: `iconst_<n>`, `ifgt`, `iinc`, etc...

### TASK DISTRIBUTION

- Ana Barros:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Tests
  - README.md
  - Part of Jasmin

- João Costa:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Optimizations
  - Jasmin
  - Tests
  - Register allocation

- João Lucas:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Part of the OLLIR
  - Tests
  - Part of Jasmin

- Ricardo Fontão:
  - Part of the syntactic analysis
  - Part of the semantic analysis
  - Code examples for delivery
  - Tests
  - Register allocation
  - build.gradle

### PROS

- Many extra semantic verifications (described above in the extras section of
  the SEMANTIC ANALYSIS chapter);
- During the LLIR generation, variable names are sanitized to prevent problems
  like: variables named 'array';
- Extra optimizations (described in the code generation section and below);
- When using constant propagation and constant folding, we apply the propagation
  to "if" and "while"'s bodies when possible, e.g.:

  ```java
  int i = 0;
  if (j < 0) {
    i = i * 2;
  } else {
    i = 2;
  }
  i = i + 1;

  // becomes

  int i = 0;
  if (j < 0) {
    i = 0; // constant propagation and folding
  } else {
    i = 2;
  }
  // notice that the constant wasn't propagated here
  i = i + 1;
  ```

- Increments/decrements by 0, such as: `i = i + 0` are skipped;
- Increments/decrements also make of the `iinc` instruction when written like
  so: `i = 1 + i;`. Note: it isn't applied for statements such as: `i = 1 - i;`,
  but it is applied for statements such as: `i = 1 + i;`.
- Increments/decrements (iinc instructions) are preformed for all constants possible:
  all numbers between -32768 and 32767 (inclusive).
- Optimized liveness analysis: reverse order.

### CONS

- Register allocation is only performed for integer and boolean variables.



## Gradle

For this project, you need to [install Gradle](https://gradle.org/install/)

## Project setup

Copy your ``.jjt`` file to the ``javacc`` folder. If you change any of the classes generated by ``jjtree`` or ``javacc``
, you also need to copy them to the ``javacc`` folder.

Copy your source files to the ``src`` folder, and your JUnit test files to the ``test`` folder.

## Compile

To compile the program, run ``gradle build``. This will compile your classes to ``classes/main/java`` and copy the JAR
file to the root directory. The JAR file will have the same name as the repository folder.

### Run

To run you have two options: Run the ``.class`` files or run the JAR.

### Run ``.class``

To run the ``.class`` files, do the following:

```cmd
java -cp "./build/classes/java/main/" <class_name> <arguments>
```

Where ``<class_name>`` is the name of the class you want to run and ``<arguments>`` are the arguments to be passed
to ``main()``.

### Run ``.jar``

To run the JAR, do the following command:

```cmd
java -jar <jar filename> <arguments>
```

Where ``<jar filename>`` is the name of the JAR file that has been copied to the root folder, and ``<arguments>`` are
the arguments to be passed to ``main()``.

## Test

To test the program, run ``gradle test``. This will execute the build, and run the JUnit tests in the ``test`` folder.
If you want to see output printed during the tests, use the flag ``-i`` (i.e., ``gradle test -i``). You can also see a
test report by opening ``build/reports/tests/test/index.html``.

## Checkpoint 1

For the first checkpoint the following is required:

1. Convert the provided e-BNF grammar into JavaCC grammar format in a .jj file
2. Resolve grammar conflicts (projects with global LOOKAHEAD > 1 will have a penalty)
3. Proceed with error treatment and recovery mechanisms for the while expression
4. Convert the .jj file into a .jjt file
5. Include missing information in nodes (i.e. tree annotation). E.g. include class name in the class Node.
6. Generate a JSON from the AST

### JavaCC to JSON

To help converting the JavaCC nodes into a JSON format, we included in this project the JmmNode interface, which can be
seen in ``src-lib/pt/up/fe/comp/jmm/JmmNode.java``. The idea is for you to use this interface along with your SimpleNode
class. Then, one can easily convert the JmmNode into a JSON string by invoking the method JmmNode.toJson().

Please check the SimpleNode included in this repository to see an example of how the interface can be implemented, which
implements all methods except for the ones related to node attributes. How you should store the attributes in the node
is left as an exercise.

### Reports

We also included in this project the class ``src-lib/pt/up/fe/comp/jmm/report/Report.java``. This class is used to
generate important reports, including error and warning messages, but also can be used to include debugging and logging
information. E.g. When you want to generate an error, create a new Report with the ``Error`` type and provide the stage
in which the error occurred.

### Parser Interface

We have included the interface ``src-lib/pt/up/fe/comp/jmm/JmmParser.java``, which you should implement in a class that
has a constructor with no parameters (please check ``src/Main.java`` for an example). This class will be used to test
your parser. The interface has a single method, ``parse``, which receives a String with the code to parse, and returns a
JmmParserResult instance. This instance contains the root node of your AST, as well as a List of Report instances that
you collected during parsing.

To configure the name of the class that implements the JmmParser interface, use the file ``parser.properties``.

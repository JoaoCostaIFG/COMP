options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(JmmTree)


public class JmmTree
{
    public static void main(String args[]) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		JmmTree jmmTree = new JmmTree(System.in);
		SimpleNode root = jmmTree.Program(); // returns reference to root node
        	
		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
	
}

PARSER_END(JmmTree)

SKIP :
{
	" " | "\r" | "\t"
}

TOKEN:
{
    <SPAR: "("> | <EPAR: ")">
    |   <SBRAK: "["> | <EBRAK: "]" >
    |   <SCURL: "{"> | <ECURL: "}">
    |   <NEW: "new">
    |   <THIS: "this">
    |   <TRUE: "true"> | <FALSE: "false">
    |   <DOT: "."> | <COMMA: ",">
    |   <NOT: "!"> | <AND: "&&"> | <LESSTHAN: "<">
    |   <ADD: "+"> | <SUB: "-"> | <MULT: "*"> | <DIV: "/">
    |   <ATTRIB: "=">
    |   <SEMICOLON: ";">
    |   <IF: "if"> | <ELSE: "else">
    |   <WHILE: "while">
    |   <BOOL: "boolean"> | <INT: "int">
    |   <VOID: "void">
    |   <PUBLIC: "public"> | <STATIC: "static">
    |   <MAIN: "main"> | <STRING: "String">
    |   <CLASS: "class"> | <EXTENDS: "extends">
    |   <IMPORT: "import">
    |   <RET: "return">
    |   <LEN: "length">
    |   <IDENTIFIER: ["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a"-"z", "_", "$"])*>
    |	<INTEGER: (["0"-"9"])+>
	|   <LF: "\n">
}

SimpleNode Program(): {}
{
  ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;} // Java code inside brackets
}

void ImportDeclaration(): {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <SCURL>
        (VarDeclaration())* (MethodDeclaration())* <ECURL>
}

void VarDeclaration(): {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration(): {}
{
    LOOKAHEAD(2)

    <PUBLIC> Type() <IDENTIFIER>
    <SPAR>
        [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*]
    <EPAR>
    <SCURL>
        (VarDeclaration())* (Statement())*
        <RET> Expression() <SEMICOLON>
    <ECURL>
    |   <PUBLIC> <STATIC> <VOID> <MAIN>
        <SPAR>
            <STRING> <SBRAK> <EBRAK> <IDENTIFIER>
        <EPAR>
        <SCURL>
            (VarDeclaration())* (Statement())*
        <ECURL>
}

void Type() : {}
{
    LOOKAHEAD(2)

    <INT> <SBRAK> <EBRAK>
    |   <BOOL>
    |   <INT>
    |   <IDENTIFIER>
}

void Statement() : {}
{
    <IDENTIFIER> <SEMICOLON>
}

void Expression() : {}
{
    //Expression() (<AND> | <LESSTHAN> | <ADD> | <SUB> | <MULT> | <DIV>) Expression()
    <IDENTIFIER>
}
